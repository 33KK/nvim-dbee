# DBee Architecture Overview

The plugin is created from 2 parts:

- Lua frontend
- Go backend

These two parts should have clearly defined borders and not "leak"
responsibilities.

## Lua Architecture

```
                         │                                           ┌─────────────┐             ┌─────────┐
                         │    "dbee"            ┌────────────────────►             ├─────────────►         │
                         │                      │                    │   handler   │   mapping   │   Go    │
                         │                      │                 ┌──►             ├─────────────►         │
                         │                      │                 │  └─────────────┘             └─────────┘
                         │      ┌────────────┐  │                 │
                         │      │            │  │                 │
┌───────────────┐        │      │   drawer   ├──┤                 │
│               │        │      │            │  │                 │
│   projector   │        │      └────────────┘  │  ┌────────────┐ │
│   extension   ├────────►                      │  │            │ │
│               │        │                      └──►   editor   ├─┘
└───────────────┘        │                         │            │
                         │                         └────────────┘
                         │
                         │
                         │
                         │      ┌─────────────┐     ┌────────────┐
                         │      │             │     │            │
                         │      │   install   │     │   loader   │
                         │      │             │     │            │
                         │      └─────────────┘     └────────────┘
                         │
```

Description:

- The "dbee" package consists of 3 major functional packages, 1 install package
  and additional "helper" packages.
- `install` package is independent of the other packages and is used for
  installation of the compiled go binary using the manifest generated by the CI
  pipeline.
- `loader` package is also independent and is used as the default loading and
  saving method in the config, which is later consumed by the handler
- `drawer` is the "tree" view in UI - it consumes the editor (to provide
  scratchpad view and to manage scratchpads) and the handler (for managing
  connections and providing layout of each database).
- `editor` is the "scratchpad" window in the UI and is used for managing
  scratchpads. It also consumes the handler in order to execute selected
  queries.
- `handler` is a mapping to Go backend - it holds all connections (a connection
  is an instance of the database) and manages them all calls to backend go
  through here. Handler also manages the "results" window in UI. handler is also
  responsible for providing layouts of databases to drawer.
- `projector extension` acts as an outside "client" and registers dbee as an
  output for nvim-projector.

## Go Architecture

As We said, the Go backend is accessed exclusively through `handler` in lua. The
handler reads configurations for databases, remembers them and registers them in
the backend as well. This way, both `handler` and go's `main()` function have
knowledge of active connections.

When a handler wants to perform an action on a specific connection, it sends the
connection's id in the request to go.

```
                            │
                            │    "main.go"
                            │
                            │    ┌──────────────────────────────┐
                            │    │ map of                       │
                            │    │ connections                  │             ┌──────┐
                            │    │                              │             │┼┼┼┼┼┼│
                            │    │ ┌──────────────────────────┐ │             └──────┤
                            │    │ │ postgres_xyz             │ │    ┌────────►  DB  │
                            │    │ │                          │ │    │        ┌──────┤
                            │    │ │  ┌─────────────────────┐ │ │    │        │┼┼┼┼┼┼│
                            │    │ │  │clients (postgres)   ├────────┘        └──────┘
                            │    │ │  └────────┬────────────┘ │ │
                            │    │ │           │              │ │
                            │    │ │         iter     ┌─ ── ── ── ── ── ─iter ── ── ── ── ── ── ──
                            │    │ │           │      │       │ │                                 │
                            │    │ │ ┌─────────▼──────▼─────┐ │ │
                            │    │ │ │cache                 │ │ │                                 │
                            │    │ │ │                      │ │ │                ┌─────────────┐
                            │    │ │ │ - read first page ──────────────buffer────►             │  │
┌─────────────────┐         │    │ │ │ - read rest in bg    │ │ │                │             │
│                 │         │    │ │ │                   ┌─────────────json──────►             │  │
│   handler.lua   ├─────────►    │ │ │                   │  │ │ │                │   outputs   │
│                 │         │    │ │ │ - idle ...  ──────┼─────────────csv───────►             │  │
└─────────────────┘         │    │ │ │                   │  │ │ │                │             │
                            │    │ │ │                   └─────────────buffer────►             │  │
                            │    │ │ │                      │ │ │                └─────────────┘
                            │    │ │ │                      │ │ │                                 │
                            │    │ │ │                      │ │ │                ┌─────────────┐
                            │    │ │ │  - flush ─────────────────────────────────►   history   ├ ─┘
                            │    │ │ │                      │ │ │                │   output    │
                            │    │ │ └──────────────────────┘ │ │                └─────────────┘
                            │    │ │                          │ │
                            │    │ └──────────────────────────┘ │
                            │    │                              │
                            │    │ ┌──────────────────────────┐ │
                            │    │ │ sqlite_123               │ │
                            │    │ │  ┌────────────────┐      │ │
                            │    │ │  │clients (sqlite)│      │ │
                            │    │ │  └────────────────┘      │ │
                            │    │ │                          │ │
                            │    │ └──────────────────────────┘ │
                            │    │                              │
                            │    │            ...               │
                            │    │                              │
                            │    └──────────────────────────────┘
                            │
```

Now that we have a map of connections, we can focus on how each connection is
structured:

There are 2 primarily used result types in the connection:

- `IterResult` - result in a form of an iterator returned by the specific
  driver.
- `Result` - full in-memory result set, which is sent in full or in chunks to
  outputs.

Each connection has a specific driver implementation (`clients`) which are
required to implement "query" functionality and return an `IterResult` which is
an iterator over the results returned from the database.

Then the client's internal `cache` reads the ammount of results required for the
first page (specified as a parameter) in the main thread and it immediately
sends it (drained first page `Result`) to the specified output (`buffer`) - this
makes an impression that results are available right away.

As soon as the first page is read, a background process is spawned which drains
the remaining results to connections's internal cache.

When the iterator is drained and all results are in cache, we can do a few
things with it:

- send a chunk of `Result` to an output (e.g. page of the result) - usually used
  by `buffer` output
- send a full `Result` to an output - useful for "saving" (e.g. json or csv
  output)

When a user makes a new request to the client (executes a query), the in-memory
`Result` is flushed to history output, which saves it on disk for possible
latter consumption.

Note: *`buffer`, `json` and `csv` all implement the same `Output` interface and
could be used interchangably. Simillarly, `clients` and `history` implement the
same `Input` interface.*
